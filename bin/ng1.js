#!/usr/bin/env node

const escodegen = require("escodegen");
const acorn = require("acorn");
const _ = require("lodash");
const u = require("./util");
const path = require("path");
const fs = require("fs");

// const conf = {
//   desc: "\n* generated by routs, don't modify \n* author: sankooc\n",
//   prefix: "/api",
//   name: "system",
//   routes: [
//     {
//       alias: "getPanda",
//       desc: "get panda object",
//       path: "/:name",
//       method: "post"
//     }
//   ]
// };

const wrap = route => {
  const { method, desc, alias, path } = route;
  const params = u.parseParams(path);

  let extra = {
    type: "ObjectExpression",
    properties: [
      {
        type: "Property",
        method: false,
        shorthand: false,
        computed: false,
        key: {
          type: "Identifier",
          name: "params"
        },
        value: {
          type: "Identifier",
          name: "query"
        },
        kind: "init"
      }
    ]
  };
  const { exp, qur } = u.splitPath(route.path);

  switch (method) {
    case "post":
    case "put":
      extra = {
        type: "Identifier",
        name: "option"
      };
      params.push("option");
      break;
    default:
      params.push("query");
  }
  const args = [
    exp.length === 0
      ? u.createLiteral(qur[0])
      : {
          type: "TemplateLiteral",
          expressions: exp.map(name => ({ type: "Identifier", name })),
          quasis: qur.map(name => ({
            type: "TemplateElement",
            value: { raw: name, cooked: name },
            tail: false
          }))
        },
    extra
  ];
  const rs = {
    type: "ExpressionStatement",
    expression: {
      type: "AssignmentExpression",
      operator: "=",
      left: {
        type: "MemberExpression",
        object: {
          type: "ThisExpression"
        },
        property: {
          type: "Identifier",
          name: route.alias
        },
        computed: false
      },
      right: {
        type: "ArrowFunctionExpression",
        id: null,
        generator: false,
        expression: true,
        params: params.map(p => ({ type: "Identifier", name: p })),
        body: {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: "$http"
            },
            property: {
              type: "Identifier",
              name: method
            },
            computed: false
          },
          arguments: args
        }
      }
    }
  };
  if (desc) {
    rs.leadingComments = u.createCommnet(desc);
  }
  return rs;
};

const generate = angConf => {
  const { desc, prefix, name, routes } = angConf;
  const meta = {
    type: "Program",
    body: [],
    sourceType: "module"
  };

  meta.body.push({
    type: "ImportDeclaration",
    specifiers: [
      {
        type: "ImportDefaultSpecifier",
        local: {
          type: "Identifier",
          name: "angular"
        }
      }
    ],
    leadingComments: u.createCommnet(desc, "Block"),
    source: {
      type: "Literal",
      value: "angular",
      raw: "'angular'"
    }
  });

  meta.body.push({
    type: "VariableDeclaration",
    declarations: [
      {
        type: "VariableDeclarator",
        id: {
          type: "Identifier",
          name: "app"
        },
        init: {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: "angular"
            },
            property: {
              type: "Identifier",
              name: "module"
            },
            computed: false
          },
          arguments: [
            {
              type: "Literal",
              value: "app",
              raw: "'app'"
            }
          ]
        }
      }
    ],
    kind: "const"
  });

  const serviceName = {
    type: "Literal",
    value: `$${name}Service`,
    raw: `'$${name}Service'`
  };
  const service = {
    type: "FunctionExpression",
    id: null,
    generator: false,
    expression: false,
    params: [
      {
        type: "Identifier",
        name: "$http"
      }
    ],
    body: {
      type: "BlockStatement",
      body: routes.map(wrap)
    }
  };
  meta.body.push({
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: {
          type: "Identifier",
          name: "app"
        },
        property: {
          type: "Identifier",
          name: "service"
        },
        computed: false
      },
      arguments: [serviceName, service]
    }
  });
  return escodegen.generate(meta, { comment: true });
};

const start = () => {
  if (process.argv.length < 4) {
    throw Error("arge");
  }
  const __path = path.resolve(process.argv[2]);

  const __target = path.resolve(process.argv[3]);

  if (!fs.existsSync(__path)) {
    throw Error("config file not exist: " + __path);
  }
  const rc = require(__path);

  const rcons = u.parseRoute(rc);

  if (!fs.existsSync(__target)) {
    fs.mkdirSync(__target);
  }

  for (const conf of rcons) {
    const content = generate(conf);
    const _path = path.join(__target, `${conf.name}_gen.js`);
    fs.writeFileSync(_path, content);
  }
};

start();

// console.log(generate(conf));
